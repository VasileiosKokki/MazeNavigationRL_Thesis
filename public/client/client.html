<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Multiplayer game client</title>
	<style>
		body, html {
			width: 100%;
			height: 100%;
			margin: 0px;
			border: 0;
			padding: 0;
			overflow: hidden;
			/*  Disable scrollbars */
			display: block;
			/* No floating content on sides */
		}
		#death-element {
			opacity: 0%;
			bottom: 50%;
			transition: opacity 2s ease;
		}
		#connection-element-1 {
			bottom: 50%;
			opacity: 1;
			transition: opacity 0.5s ease
		}
		#connection-layer {
			background-color:darkblue;
			z-index: 1;
			position: absolute;
			width: 100%; /* Adjust the width as needed */
			height: 100%;
			pointer-events: none;
			transition: background-color 0.5s ease
		}
	</style>
	<link rel="stylesheet" href="./styles.css">
</head>
<body>
	<div id="connection-layer" class="ui-layer">
		<div id="connection-element-1" class="ui-element">
			<span id="connection-text-1">(Waiting for WebSocket Connection)</span>
		</div>
		<div id="connection-element-2" class="ui-element">
			<span id="connection-text-2">Connection Failed</span>
		</div>
	</div>
	<div id="death-layer" class="ui-layer">
		<div id="death-element" class="ui-element">
			<span id="respawn-text">(Press 'Enter' To Respawn)</span>
		</div>
	</div>
	<div id="score-bar" class="ui-bar">
		<div id="score-fill" class="ui-fill"></div>
		<div id="score-element" class="ui-element">
			Score: <span id="score-value">0</span>
		</div>
	</div>
	<div id="level-bar" class="ui-bar">
		<div id="level-fill" class="ui-fill"></div>
		<div id="level-element" class="ui-element">
			Level: <span id="level-value">1</span>
		</div>
	</div>
	<canvas id="gameArea" tabindex="1"></canvas>
	<script type="module">

		import {
			getBaseDivisorAtLevel, handleKeyAction,
			handleMouseWheel, handleVisibilityChange,
			handleWebSocketErrorOrClose, onMouseMove,
			updateCanvasSize
		} from "./functions.js";

		const worker = new Worker("worker.js", { type: "module" });
		const canvas = document.getElementById('gameArea');
		const scaleFactor = 1 / window.devicePixelRatio;
		canvas.style.transform = `scale(${scaleFactor})`;
		const offscreen = canvas.transferControlToOffscreen();
		worker.postMessage({ type:'canvas', data:offscreen }, [offscreen]);
		updateCanvasSize(scaleFactor, worker);


		canvas.focus();     // doesn't work well with live preview

		let zoomLevel = 1;
		let angle;
		let arrowUpPressed = false;
		let arrowDownPressed = false;
		let arrowRightPressed = false;
		let arrowLeftPressed = false;
		let isShooting = false;
		let deathFlag = false;
		const throttleInterval = 40; // Set the throttle interval in milliseconds
		let lastMouseMoveTime = 0;
		let score;
		let highScore;
		let drawables = [];

		function Drawable(clientId, name, width, height, topLeftX, topLeftY, color, maxHealth, currentHealth, shape, type, shootingAngle){
		this.clientId = clientId;
		this.name = name;
		this.width = width;
		this.height = height;
		this.topLeftX = topLeftX;
		this.topLeftY = topLeftY;
		this.color = color; 
		this.maxHealth = maxHealth;
		this.currentHealth = currentHealth;
		this.shape = shape;
		this.type = type;
		this.shootingAngle = shootingAngle;
		};

		let url = window.location.href;
		
		if (url.startsWith('http://')) {
  		  // Remove 'http://' from the beginning
  		  url = url.slice(7);
		} else if (url.startsWith('https://')) {
		  // Remove 'https://' from the beginning
		  url = url.slice(8);
		}

		// Split the URL by '/' to get the domain
		let parts = url.split(':');
		let domain = parts[0]; // The first part is the domain
		console.log(parts);
		let websocket;
		let playerName = window.playerName;
		const port = window.port

		let maxScore;
		let scorePercentage;

		


			if (port != undefined){
				websocket = new WebSocket(`ws://${domain}:${port}/connected?${playerName}`);
			}
			
			if (websocket != undefined){
				websocket.addEventListener('message',function(event){
					if (document.getElementById('connection-layer').style.backgroundColor != 'transparent'){
						document.getElementById('connection-layer').style.backgroundColor = 'transparent';
						document.getElementById('connection-element-1').style.opacity = '0';
					}
					const blob = event.data;
					const fileReader = new FileReader();
					fileReader.readAsArrayBuffer(blob);
					fileReader.onload = function () {
  						// Get the ArrayBuffer from the FileReader result
  						const arrayBuffer = fileReader.result;

  						// Create a Uint8Array from the ArrayBuffer
  						const receivedUint8Array = new Uint8Array(arrayBuffer);

						const flagSize = "1".length; // Adjust the flag size as needed
  						const flagBuffer = receivedUint8Array.slice(-flagSize);
  						const flag = new TextDecoder().decode(flagBuffer);
						let dataWithoutFlag = receivedUint8Array.slice(0, -flagSize);
					
  						if (flag === "1") {
							if (!document.hidden){
  								// Now we can use pako to decompress the data
								dataWithoutFlag = pako.inflate(dataWithoutFlag);
								const decoder = new TextDecoder();
  								const decodedString = decoder.decode(dataWithoutFlag);
  								const message = JSON.parse(decodedString);
								passToWorkerOrNot(message);
							}
						} else {
  							// Convert decompressed data to string or process it as needed
  							const decoder = new TextDecoder();
  							const decodedString = decoder.decode(dataWithoutFlag);
  							const message = JSON.parse(decodedString);
							passToWorkerOrNot(message);
						}

					
					};
				});
				websocket.addEventListener('error', handleWebSocketErrorOrClose);
				websocket.addEventListener('close', handleWebSocketErrorOrClose);
			} else {
				handleWebSocketErrorOrClose();
			}
			


		function passToWorkerOrNot(message){
			switch(message.type){
				case 'model':
						// ----------------------------------------- Model -----------------------------------------
						drawables.length = 0;
						const arrayOfArrays = message.data;
						for (let i = 0; i < arrayOfArrays.length; i++) {
						let attributesArray = arrayOfArrays[i];
						let drawable = new Drawable(
						    attributesArray[0], // clientId
						    attributesArray[1], // name
						    attributesArray[2], // width
						    attributesArray[3], // height
						    attributesArray[4], // topLeftX
						    attributesArray[5], // topLeftY
						    attributesArray[6], // color
						    attributesArray[7], // maxHealth
							attributesArray[8], // currentHealth
							attributesArray[9], // shape
							attributesArray[10], // type
							attributesArray[11] // shootingAngle
						);
						drawables.push(drawable);
						}
						

						worker.postMessage({ type:'model', data:JSON.stringify(drawables) });
					break;
				case 'connected':
						const properId = message.data.clientId;
						const gameBoundsDimensions = message.data.gameBoundsDimensions;
						const spatialGridDimensions = message.data.spatialGridDimensions;
						const pathGridDimensions = message.data.pathGridDimensions;
						const unwalkableCells = message.data.unwalkableCells;
						const connectedData = {properId,gameBoundsDimensions,spatialGridDimensions,pathGridDimensions,unwalkableCells}
						worker.postMessage({ type:'connected', data:JSON.stringify(connectedData) });
					break;
				case 'experience':
						const level = message.data.level;
						const experience = message.data.experience;
						score = message.data.score;
						// we don't pass to worker because we use css instead of canvas
						const maxExperience = getBaseDivisorAtLevel(level);
						const experiencePercentage = experience / maxExperience;
						document.getElementById('level-value').textContent = level;
						document.getElementById('score-value').textContent = score;
						document.getElementById('level-fill').style.width = `${experiencePercentage*100}%`;


						scorePercentage = score / maxScore;
						if (scorePercentage > 1.0) {
    						scorePercentage = 1.0; // Set scorePercentage to 100% if it exceeds 100%
						}
						document.getElementById('score-fill').style.width = `${scorePercentage*100}%`;

					break;
				case 'highScore':
						maxScore = message.data.highScore;
						scorePercentage = score / maxScore;
						if (scorePercentage > 1.0) {
    						scorePercentage = 1.0; // Set scorePercentage to 100% if it exceeds 100%
						}
						document.getElementById('score-fill').style.width = `${scorePercentage*100}%`;
					break;
				case 'death':
						deathFlag = message.data;
						document.getElementById('death-layer').style.backgroundColor = '#4a080827';
						document.getElementById('death-element').style.transition = 'opacity 2s ease';
						document.getElementById('death-element').style.opacity = '100%';						
					break;
				default:
					break;
			}
		}





		// ----------------------------------------- Start of Movement -----------------------------------------

		canvas.addEventListener('keydown',function(event){

			// ------------------------------------- Movement ---------------------------

			if (event.repeat) {
   				 return; // Ignore key repeats
  			}

			if (event.key === 'ArrowUp' || event.code === 'KeyW') {	
    		arrowUpPressed = true;
  			} else if (event.key === 'ArrowDown' || event.code === 'KeyS') {
    		arrowDownPressed = true;
  			} else if (event.key === 'ArrowRight' || event.code === 'KeyD') {
    		arrowRightPressed = true;
  			} else if (event.key === 'ArrowLeft' || event.code === 'KeyA') {
    		arrowLeftPressed = true;
  			}



			if ((websocket != undefined) && (websocket.readyState == 1)){
				// 4th level - 4 buttons
				if (arrowUpPressed && arrowDownPressed && arrowRightPressed && arrowLeftPressed) {
				const message = {type:'userAction',data:'ArrowNotClicked'};
				websocket.send(JSON.stringify(message));
				} else {

				handleKeyAction(websocket, arrowUpPressed, arrowDownPressed, arrowRightPressed, arrowLeftPressed);

				}
			}


			// ------------------------------------- Respawn ---------------------------

			if (event.code == 'Enter'){
				if (deathFlag == true){
					deathFlag = false;
					const message2 = {type:'userRespawn'};
					websocket.send(JSON.stringify(message2));
					document.getElementById('death-layer').style.backgroundColor = 'transparent';
					document.getElementById('death-element').style.transition = 'none';
					document.getElementById('death-element').style.opacity = '0%';
				}
			}
			
		});

		canvas.addEventListener('keyup',function(event){

			if (event.key === 'ArrowUp' || event.code === 'KeyW') {
    		arrowUpPressed = false;
  			}
			if (event.key === 'ArrowDown' || event.code === 'KeyS') {
    		arrowDownPressed = false;
  			}
			if (event.key === 'ArrowRight' || event.code === 'KeyD') {
    		arrowRightPressed = false;
  			}
			if (event.key === 'ArrowLeft' || event.code === 'KeyA') {
    		arrowLeftPressed = false;
  			}


			if ((websocket != undefined) && (websocket.readyState == 1)){
				handleKeyAction(websocket, arrowUpPressed, arrowDownPressed, arrowRightPressed, arrowLeftPressed);


				// 0th level - 0 buttons
				if (!arrowUpPressed && !arrowDownPressed && !arrowRightPressed && !arrowLeftPressed){
					const message = {type:'userAction',data:'ArrowNotClicked'};
					websocket.send(JSON.stringify(message));
				}
			}

		});

		// ----------------------------------------- End of Movement -----------------------------------------




		// ----------------------------------------- Start of Projectiles -----------------------------------------

		
		canvas.addEventListener('mousedown',function(event){
			
			if ((websocket != undefined) && (websocket.readyState == 1)){
				if (event.button == 0) {	
					isShooting = true;
					const message = {type:'userProjectile',shoot:'true'};
					websocket.send(JSON.stringify(message))	
				}
			}	
		
		});

		canvas.addEventListener('mousemove', (event) => ({ lastMouseMoveTime, angle } = onMouseMove(event, lastMouseMoveTime, angle, throttleInterval, websocket, canvas, scaleFactor)));

	
		canvas.addEventListener('mouseup',function(event){
			
			if ((websocket != undefined) && (websocket.readyState == 1)){
				if (event.button == 0) {
					isShooting = false;
					const message = {type:'userProjectile',shoot:'false'};
					websocket.send(JSON.stringify(message));
				}
			}
			
		});


		// ----------------------------------------- End of Projectiles -----------------------------------------

		



		// ----------------------------------------- Start of Other Event Listeners -----------------------------------------


		// to prevent right click
		canvas.addEventListener('contextmenu', function (event) {
            event.preventDefault();
        });

		// for zoom
		canvas.addEventListener('wheel', (event) => zoomLevel = handleMouseWheel(event, worker, zoomLevel));

		// Update canvas size when the window is resized
		window.addEventListener('resize', () => updateCanvasSize(scaleFactor, worker));
		
		// to disable inputs when player clicks outside of canvas
		window.addEventListener('blur', () => ({ arrowUpPressed, arrowDownPressed, arrowRightPressed, arrowLeftPressed, isShooting } = handleVisibilityChange(websocket, arrowUpPressed, arrowDownPressed, arrowRightPressed, arrowLeftPressed, isShooting, angle)));


		


		// ----------------------------------------- End of Other Event Listeners -----------------------------------------

		

	</script>
</body>
</html>